/*
 * Threshold.h
 *
 *  Created on: Feb 23, 2015
 *      Author: ataylor
 */
#ifndef EXTERN_CALL_FINDER_H_
#define EXTERN_CALL_FINDER_H_
#include "RosThresholds.h"




using namespace llvm;
namespace ros_thresh{

class BackwardPropigate;

//Set defs

class SimpleCallGraph: public ModulePass{
public:
	static char ID;
	SimpleCallGraph();
	~SimpleCallGraph();
	virtual bool runOnFunction(Function &F);
	virtual bool runOnModule(Module &M);
	virtual void getAnalysisUsage(AnalysisUsage &AU) const override;
	call_vect getCallSites(Function* target);

private:
	func_call_map_type call_map;



};


class IfStatementPass: public ModulePass{

public:
	static char ID;
	IfStatementPass();
	~IfStatementPass();
	virtual bool runOnFunction(Function &F);
	virtual bool runOnModule(Module &M);
	virtual void getAnalysisUsage(AnalysisUsage &AU) const override;
	void getParents(block_vect* parents, BasicBlock* block);
	BasicBlock* getLocalParent(BasicBlock* node);

private:
	void addChildren(block_map children);
	void addParents();
	block_vect branch_statements;
	/* Child map -> If statements to contained blocks */
	block_map child_map;
	/* Child map -> Block to all if statements*/
	block_map parent_map;
	std::unordered_map<Function*, block_vect> if_map;
	std::unordered_map<BasicBlock*, BasicBlock*> direct_parents;
	int count;

};

class ParamUsageFinder: public ModulePass{

public:
	static char ID;
	ParamUsageFinder();
	virtual bool runOnFunction(Function &F);
	virtual bool runOnModule(Module &M);
	virtual void getAnalysisUsage(AnalysisUsage &AU) const override;
	ptr_set result_set;
	ptr_vect result_list;
	bool matches_setup_param(GetElementPtrInst * ptr_inst);
	branch_set getBranches();
	thresh_branch_vect getResults();


private:
	BackwardPropigate* back_prop_res;
	branch_set thresh_branches;
	thresh_branch_vect result_vector;
	ptr_vect params;
	int param_use_count;
	ptr_vect branch_params;
	int param_branch_count;

};

//Get
class ClassObjectAccess: public ModulePass{

public:
	static char ID;
	ClassObjectAccess();
	virtual bool runOnFunction(Function &F);
	virtual bool runOnModule(Module &M);
	virtual void getAnalysisUsage(AnalysisUsage &AU) const override;
	ptr_set getLoads(GetElementPtrInst* inst);
	ptr_set getStores(GetElementPtrInst*inst);

private:
	int _count;
	ptr_vect representatives;
	GetElementPtrInst* getRepInst(GetElementPtrInst* inst);
	void addLoad(GetElementPtrInst* inst);
	void addStore(GetElementPtrInst* inst);
	void addToStore(GetElementPtrInst* inst);
	ptr_map_type loads;
	ptr_map_type stores;
};


class ParamCallFinder : public ModulePass{


public:
	static char ID;
	ptr_vect param_ptr_list;
	ptr_set param_ptr_set;
	virtual bool runOnFunction(Function &F);
	virtual bool runOnModule(Module &M);
	ParamCallFinder();
	virtual void getAnalysisUsage(AnalysisUsage &AU) const override;
	ptr_set* getParamPtrSet();
	ptr_vect* getParamPtrList();
private:
	int totalCount;
};

class BackwardPropigate: public ModulePass{

public:
	static char ID;
//	virtual bool runOnFunction(Function &F);
	void do_an_iter();
	void iter_on_function(Function* F);
	virtual bool runOnModule(Module &M);
	bool poop(Function &F);
	BackwardPropigate();
	~BackwardPropigate();
	virtual void getAnalysisUsage(AnalysisUsage &AU) const override;
	branch_set* get_marked_branches();
	bool branch_marked(BranchInst*);
	instruction_set getDataDependencies(Instruction* inst);
	void testDataDependencies(Instruction* inst);
	instruction_set getLocalDataDependencies(Instruction* inst);
	BasicBlock* getWorkingBlock(Instruction* i);
	int pass_count;


private:
	call_pair_vect actual_calls;
	instruction_set* current_iter;
	instruction_set* next_iter;
	instruction_set visited;
	function_set func_to_examine;


	single_inst_map return_point;

	//Predicates and successors
	branch_set marked_branches;
	inst_map preds;
	inst_map succs;


	//Other passes needed to complete this pass
	ClassObjectAccess* obj_acc;
	SimpleCallGraph* call_pass;
	IfStatementPass* if_info;
};


class ExternCallFinder : public ModulePass{
public:
	static char ID;
	virtual bool runOnFunction(Function &F);
	virtual bool runOnModule(Module &M);
	ExternCallFinder();
	~ExternCallFinder();
	virtual void getAnalysisUsage(AnalysisUsage &AU) const override;


	call_pair_vect* getSites() {
		return &sites;
	}

private:
	call_pair_vect sites;
	std::string pub_name = "_ZNK3ros9Publisher7publishIN";
	std::string srv_name = "FIGURE_THIS_ONE_OUT";

};

class PrintDoms: public ModulePass{

public:
	static char ID;
	virtual bool runOnFunction(Function &F);
	virtual bool runOnModule(Module &M);
	PrintDoms();
	~PrintDoms();
	virtual void getAnalysisUsage(AnalysisUsage &AU) const override;
};


class FindConstComps: public ModulePass{

public:
	static char ID;
	virtual bool runOnModule(Module &M);
	FindConstComps();
	~FindConstComps();
	virtual void getAnalysisUsage(AnalysisUsage &AU) const override;

private:
	BackwardPropigate* back_prop_res;

};


class InstrumentBranches: public ModulePass{

public:
	static char ID;
	virtual bool runOnModule(Module &M);
	InstrumentBranches();
	~InstrumentBranches();
	virtual void getAnalysisUsage(AnalysisUsage &AU) const override;
	void instrumentBranch(BranchInst* branch);
	void instrumentBranch(thresh_branch_pair branch);

private:
	branch_set inst_to_instrument;


};

}//end namespace ros_thresh


#endif /* LLVM_TRANSFROM_THRESHOLD_H_*/
